---
eip: 191
title: Estándar de Datos Firmados
author: Martin Holst Swende (@holiman), Nick Johnson <arachnid@notdot.net>
discussions-to: https://github.com/ethereum/EIPs/issues/191
status: Final
type: Standards Track
category: ERC
created: 2016-01-20
---

# Resumen

Este ERC propone una especificación sobre cómo manejar datos firmados en contratos de Ethereum.

# Motivación

Se han creado varias implementaciones de billeteras multifirma que aceptan transacciones `pre-firmadas`. Una transacción `pre-firmada` es un bloque de datos binarios `signed_data`, junto con una firma (`r`, `s` y `v`). La interpretación de `signed_data` no ha sido especificada, lo que ha conducido a varios problemas:

* Las transacciones estándar de Ethereum pueden ser enviadas como `signed_data`. Una transacción de Ethereum puede descomponerse en los siguientes componentes: `RLP<nonce, gasPrice, startGas, to, value, data>` (de aquí en adelante llamado `RLPdata`), `r`, `s` y `v`. Si no hay restricciones sintácticas sobre `signed_data`, esto significa que `RLPdata` puede ser utilizado como una transacción `pre-firmada` sintácticamente válida.
* Las billeteras multifirma también han tenido el problema de que una transacción `pre-firmada` no ha estado ligada a un `validador` específico, es decir, a una billetera en particular. Ejemplo:
    1. Los usuarios `A`, `B` y `C` tienen la billetera `X` con esquema `2/3`
    2. Los usuarios `A`, `B` y `D` tienen la billetera `Y` con esquema `2/3`
    3. Los usuarios `A` y `B` envían transacciones `pre-firmadas` a `X`.
    4. Un atacante ahora puede reutilizar esas transacciones pre-firmadas destinadas a `X`, y enviarlas a `Y`.

## Especificación

Proponemos el siguiente formato para `signed_data`:

```
0x19 <1 byte de versión> <datos específicos de la versión> <datos a firmar>.
```

El byte inicial `0x19` está destinado a asegurar que `signed_data` no sea un RLP válido.

> Para un solo byte cuyo valor esté en el rango [0x00, 0x7f], ese byte es su propia codificación RLP.

Esto significa que cualquier `signed_data` no puede ser una única estructura RLP, sino una carga útil de `RLP` de 1 byte seguida de otra cosa. Así, cualquier `signed_data` bajo EIP-191 nunca podrá ser una transacción de Ethereum.

Además, se ha elegido `0x19` porque, desde ethereum/go-ethereum#2940, se antepone lo siguiente antes de hacer el hash en `personal_sign`:

```
"\x19Ethereum Signed Message:\n" + len(message).
```

Usar `0x19` permite extender el esquema definiendo una versión `0x45` (`E`) para manejar este tipo de firmas.

### Registro de bytes de versión

| Byte de versión | EIP            | Descripción
| ---------------- | -------------- | -----------
|    `0x00`         | [191][eip-191] | Datos con validador destinado
|    `0x01`         | [712][eip-712] | Datos estructurados
|    `0x45`         | [191][eip-191] | Mensajes de `personal_sign`

#### Versión `0x00`

```
0x19 <0x00> <dirección del validador destinado> <datos a firmar>
```

La versión `0x00` utiliza `<dirección del validador destinado>` como los datos específicos de la versión. En el caso de una billetera multifirma que realiza una ejecución basada en una firma pasada, la dirección del validador es la dirección de la propia billetera multifirma. Los datos a firmar pueden ser cualquier dato arbitrario.

#### Versión `0x01`

La versión `0x01` es para datos estructurados como se define en [EIP-712].

#### Versión `0x45` (E)

```
0x19 <0x45 (E)> <"thereum Signed Message:\n" + len(message)> <datos a firmar>
```

La versión `0x45` (E) utiliza `<"thereum Signed Message:\n" + len(message)>` como datos específicos de la versión. Los datos a firmar pueden ser cualquier dato arbitrario.

> Nota: La `E` en `Ethereum Signed Message` se refiere al byte de versión 0x45. El carácter `E` es `0x45` en hexadecimal, lo que hace que el resto, `"thereum Signed Message:\n" + len(message)`, sean los datos específicos de la versión.

[EIP-191]: ./eip-191.md  
[EIP-712]: ./eip-712.md

### Ejemplo

Los siguientes fragmentos están escritos en Solidity 0.8.0.

#### Versión `0x00`

```solidity
function signatureBasedExecution(address target, uint256 nonce, bytes memory payload, uint8 v, bytes32 r, bytes32 s) public payable {
        
    // Argumentos al calcular el hash para validar
    // 1: byte(0x19) - el byte inicial 0x19
    // 2: byte(0) - el byte de versión
    // 3: address(this) - la dirección del validador
    // 4-6: Datos específicos de la aplicación

    bytes32 hash = keccak256(abi.encodePacked(byte(0x19), byte(0), address(this), msg.value, nonce, payload));

    // Recuperar la dirección del firmante desde el hash y la firma
    addressRecovered = ecrecover(hash, v, r, s);
   
    // Lógica de la billetera
    // if (addressRecovered == owner) executeOnTarget(target, payload);
}
```

Copyright

Derechos de autor y derechos relacionados renunciados vía CC0.